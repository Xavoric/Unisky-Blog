import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as t,e as i}from"./app-DrMrOvds.js";const n="/Unisky-Blog/assets/jvm-Bg06BWiK.png",r="/Unisky-Blog/assets/heap-Dhv6LPzS.png",s={},p=i('<h1 id="java基础复习-jvm" tabindex="-1"><a class="header-anchor" href="#java基础复习-jvm"><span>Java基础复习-JVM</span></a></h1><p>JVM是指Java Virtual Machine，是将字节码文件.class编译成电脑可以运行的文件，是独立虚拟机，兼容各种操作系统，是实现java跨平台的重要部分。</p><h2 id="_1-jvm内存模型" tabindex="-1"><a class="header-anchor" href="#_1-jvm内存模型"><span>1.JVM内存模型</span></a></h2><figure><img src="'+n+'" alt="jvm" tabindex="0" loading="lazy"><figcaption>jvm</figcaption></figure><p>如上图，其中下面的大方块则代表了JVM</p><p>JVM的内存模型可以分为五个主要部分，分别是方法区、堆，虚拟机栈、本地方法栈和程序计数器。其中堆和方法区是被所有线程共享的，而栈和PCR是由线程私有的。</p><h3 id="堆的进一步分类" tabindex="-1"><a class="header-anchor" href="#堆的进一步分类"><span>堆的进一步分类</span></a></h3><figure><img src="'+r+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>堆区是分配内存最大的一部分（初始默认分配物理内存的1/64，最大允许分配物理内存的1/4），用于储存实例对象，因为大部分java对象生存周期较短，从提高垃圾回收性能的角度来说，堆会被进一步分为四个部分（如上图）</p><p>首先是两个大部分，<strong>新生代、老年代</strong>，这两个部分对应了已经生存了不同周期的对象（即经历一定次数垃圾回收后生存情况不同的对象）</p><p>新生代又可进一步划分为<strong>Eden区、toSurvivor区、fromSurvivor区</strong>,默认情况下这三个分区的比例是8:1:1，其中两个Survior区其中必定会有一个是空闲的（会交替），所以其中90%内存是可用的</p><h3 id="垃圾回收gc" tabindex="-1"><a class="header-anchor" href="#垃圾回收gc"><span>垃圾回收GC</span></a></h3><p>垃圾回收分为三种回收操作，<strong>Minor GC, Major GC, Full GC</strong>,执行频率依次下降，执行时间依次上升</p><p>Minor GC是新生代GC，Major是老年代GC，Full GC是对整个堆空间的GC</p><p>Eden区是创建新对象的内存区域，当Eden区空间不足时，会进行一次Minor GC，其中存活后的对象会被移动到其中一个Survivor区（如果能被Survivor区接受），这个对象对应的年龄也会增加1。当年龄到达一定大小（默认15），这个对象就会晋升到老年代中。</p><p>下面是几种回收操作的触发条件：</p><p>Minor GC: Eden区满，新创建对象大小超出Eden区剩余空间</p><p>Major GC和Full GC: 这两种回收操作一般是同时发生的，触发条件比较多：</p><ul><li>1.晋升到老年代的对象平均大小超出老年代剩余空间</li><li>2.Minor GC后存活的对象超出老年代剩余空间</li><li>3.调用System.gc()申请GC</li><li>4.向堆内分配大对象</li></ul><h3 id="判断对象存活情况" tabindex="-1"><a class="header-anchor" href="#判断对象存活情况"><span>判断对象存活情况</span></a></h3><h4 id="_1-引用计数法" tabindex="-1"><a class="header-anchor" href="#_1-引用计数法"><span>(1).引用计数法</span></a></h4><p>若一个对象不被任何引用指向，认为是垃圾。这种算法无法检测到环的情况，通常不被使用。</p><h4 id="_2-可达性分析法" tabindex="-1"><a class="header-anchor" href="#_2-可达性分析法"><span>(2).可达性分析法</span></a></h4><p>首先确定一个GC Roots,可以是虚拟机栈中引用的对象、方法区中引用的对象等</p><p>通过GC Roots向下搜索，其路径形成引用链，若一个对象无法通过任何引用链到达GC Roots时被视为垃圾，可以解决环形引用问题，是虚拟机常用算法</p><h3 id="gc算法" tabindex="-1"><a class="header-anchor" href="#gc算法"><span>GC算法</span></a></h3><h4 id="_1-标记-清除算法" tabindex="-1"><a class="header-anchor" href="#_1-标记-清除算法"><span>(1).标记-清除算法</span></a></h4><p>为每一个对象存储一个标记位，存储对象的生存情况。</p><p>第一个阶段是标记阶段，会为每个对象进行生存情况的检查，并对标记位进行更新。第二个阶段是清除阶段，会对死亡对象进行清除。</p><p>缺点是需要挂起，效率较低，导致内存碎片。通常用于老年代的GC。</p><h4 id="_2-标记-整理算法" tabindex="-1"><a class="header-anchor" href="#_2-标记-整理算法"><span>(2).标记-整理算法</span></a></h4><p>在标记-清除的基础上改进了内存碎片问题。</p><p>第一个标记阶段没有变化，主要是第二个阶段，在这个阶段先将没有死亡的对象移动到另一块空间的连续区域，然后将剩余的所有对象清除。</p><p>缺点是需要更新对象引用。常用于老年代GC</p><h4 id="_3-复制算法" tabindex="-1"><a class="header-anchor" href="#_3-复制算法"><span>(3).复制算法</span></a></h4><p>将内存分为两部分，使用其中一部分储存对象，当这部分内存填满的时候将存活的对象移动到另一块内存中，再清空之前的内存，两块内存区域交换角色，如此循环。</p><p>缺点是可能导致内存浪费。常用于新生代，在Eden和两个Survivor区间执行复制算法。</p><h3 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区"><span>方法区</span></a></h3><p>储存常量池、static静态变量，方法信息（修饰符、方法名称、返回值类型、参数列表等）以及类信息等</p><h3 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈"><span>虚拟机栈</span></a></h3><p>储存8大基本数据类型，对象引用和实例方法</p><h3 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h3><p>储存本地接口库中调用的方法（native关键词）</p><h3 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h3><p>每个线程启动都会创建一个程序计数器，保存jvm指令，指向下一条指令地址，生命周期与线程相同。</p><h2 id="_2-类加载器" tabindex="-1"><a class="header-anchor" href="#_2-类加载器"><span>2.类加载器</span></a></h2><p>类加载器的功能是将类文件（.class文件）从硬盘读取到内存中，在堆中创建对象，将静态数据转化成方法区内数据结构</p><p>类加载器包括<strong>引导类加载器、拓展类加载器、系统类加载器、自定义类加载器</strong></p><h3 id="双亲委派机制" tabindex="-1"><a class="header-anchor" href="#双亲委派机制"><span>双亲委派机制</span></a></h3><p>类加载器收到类加载请求时，优先交给父类加载器去完成，一直向上委托直到引导类加载器。如父类无法加载，则通知子类加载器往下加载。</p>',50),l=[p];function o(c,h){return e(),t("div",null,l)}const g=a(s,[["render",o],["__file","JavaReview4.html.vue"]]),m=JSON.parse('{"path":"/posts/study/JavaReview4.html","title":"Java基础复习-JVM","lang":"zh-CN","frontmatter":{"date":"2024-05-16T00:00:00.000Z","category":["学习"],"tag":["面试","Java"],"star":false,"sticky":false,"sidebar":false,"breadcrumb":false,"footer":"I will reach the star.","description":"Java基础复习-JVM JVM是指Java Virtual Machine，是将字节码文件.class编译成电脑可以运行的文件，是独立虚拟机，兼容各种操作系统，是实现java跨平台的重要部分。 1.JVM内存模型 jvmjvm 如上图，其中下面的大方块则代表了JVM JVM的内存模型可以分为五个主要部分，分别是方法区、堆，虚拟机栈、本地方法栈和程序计...","head":[["meta",{"property":"og:url","content":"https://xavoric.github.io/Unisky-Blog/Unisky-Blog/posts/study/JavaReview4.html"}],["meta",{"property":"og:site_name","content":"宙宇空"}],["meta",{"property":"og:title","content":"Java基础复习-JVM"}],["meta",{"property":"og:description","content":"Java基础复习-JVM JVM是指Java Virtual Machine，是将字节码文件.class编译成电脑可以运行的文件，是独立虚拟机，兼容各种操作系统，是实现java跨平台的重要部分。 1.JVM内存模型 jvmjvm 如上图，其中下面的大方块则代表了JVM JVM的内存模型可以分为五个主要部分，分别是方法区、堆，虚拟机栈、本地方法栈和程序计..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-06T08:08:36.000Z"}],["meta",{"property":"article:author","content":"Unisky"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2024-05-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-06T08:08:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java基础复习-JVM\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-06T08:08:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Unisky\\"}]}"]]},"headers":[{"level":2,"title":"1.JVM内存模型","slug":"_1-jvm内存模型","link":"#_1-jvm内存模型","children":[{"level":3,"title":"堆的进一步分类","slug":"堆的进一步分类","link":"#堆的进一步分类","children":[]},{"level":3,"title":"垃圾回收GC","slug":"垃圾回收gc","link":"#垃圾回收gc","children":[]},{"level":3,"title":"判断对象存活情况","slug":"判断对象存活情况","link":"#判断对象存活情况","children":[]},{"level":3,"title":"GC算法","slug":"gc算法","link":"#gc算法","children":[]},{"level":3,"title":"方法区","slug":"方法区","link":"#方法区","children":[]},{"level":3,"title":"虚拟机栈","slug":"虚拟机栈","link":"#虚拟机栈","children":[]},{"level":3,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":3,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]}]},{"level":2,"title":"2.类加载器","slug":"_2-类加载器","link":"#_2-类加载器","children":[{"level":3,"title":"双亲委派机制","slug":"双亲委派机制","link":"#双亲委派机制","children":[]}]}],"git":{"createdTime":1725610116000,"updatedTime":1725610116000,"contributors":[{"name":"Xavoric","email":"3024008334@qq.com","commits":1}]},"readingTime":{"minutes":4.7,"words":1410},"filePathRelative":"posts/study/JavaReview4.md","localizedDate":"2024年5月16日","excerpt":"\\n<p>JVM是指Java Virtual Machine，是将字节码文件.class编译成电脑可以运行的文件，是独立虚拟机，兼容各种操作系统，是实现java跨平台的重要部分。</p>\\n<h2>1.JVM内存模型</h2>\\n<figure><figcaption>jvm</figcaption></figure>\\n<p>如上图，其中下面的大方块则代表了JVM</p>\\n<p>JVM的内存模型可以分为五个主要部分，分别是方法区、堆，虚拟机栈、本地方法栈和程序计数器。其中堆和方法区是被所有线程共享的，而栈和PCR是由线程私有的。</p>\\n<h3>堆的进一步分类</h3>\\n<figure><figcaption>alt text</figcaption></figure>","autoDesc":true}');export{g as comp,m as data};
