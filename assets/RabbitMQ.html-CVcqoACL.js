import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,e as o}from"./app-DrMrOvds.js";const n="/Unisky-Blog/assets/RMQ1-C_zcjH_I.png",i={},r=o('<h1 id="消息队列和rabbitmq" tabindex="-1"><a class="header-anchor" href="#消息队列和rabbitmq"><span>消息队列和RabbitMQ</span></a></h1><h2 id="_1-简介" tabindex="-1"><a class="header-anchor" href="#_1-简介"><span>1.简介</span></a></h2><p>RabbitMQ是最常见的消息队列中间件之一，相比Kafka在中小型项目中应用更广。该文针对RabbitMQ在Java环境的使用进行展开。主要是通过RabbitMQ来深入理解消息队列(下简称MQ)这一种中间件。</p><p>该中间件是基于Erlang语言开发的，也自带Erlang的Emnesia分布式实时关系数据库</p><h2 id="_2-控制界面" tabindex="-1"><a class="header-anchor" href="#_2-控制界面"><span>2.控制界面</span></a></h2><p>通过<code>http://localhost:15672/</code>可以访问RabbitMQ的控制中心，需要输入账号密码，默认需要在localhost下使用guest/guest才能登陆。</p><p>在控制界面中可以看到消息队列的信息接收情况以及相关统计信息，也可查看消息内部的payload（即消息主体） 也可以查看目前消息队列的连接情况、硬件使用情况等</p><h2 id="_3-生产者-p-与消费者-c" tabindex="-1"><a class="header-anchor" href="#_3-生产者-p-与消费者-c"><span>3.生产者(P)与消费者(C)</span></a></h2><p>在消息队列中，向消息队列发送消息的一方被称为<strong>生产者(Producer)</strong>，顾名思义就是生产消息，生产者可以异步地向MQ中传递消息，仅需要与消息队列进行短期的连接。 而从消息队列中接收消息，并完成相应工作的一方被称为<strong>消费者(Consumer)</strong>，完成工作的行为被称为是消费。消费者需要保持与MQ的连接和监听。</p><p>通常情况下P产生的消息是按照顺序进入MQ的，C也按照队列顺序消费消息</p><p>如果存在多个消费者同时运行，MQ会<strong>默认</strong>按照轮询(Round-robin)的方式将消息均匀分给各个消费者，在理想情况下每个消费者接收到的消息数量是基本相同的。设置<code>prefetchCount=1</code>可以要求调度时仅考虑空闲消费者，不会出现频繁等待运行中消费者的情况。</p><h2 id="_4-消息确认机制" tabindex="-1"><a class="header-anchor" href="#_4-消息确认机制"><span>4.消息确认机制</span></a></h2><p>RabbitMQ支持<strong>消息确认(message Acknowledge)<strong>机制，即消费者通过发送确认消息来告诉MQ消息的处理情况，MQ一旦接收到确认即可删除消息。RabbitMQ提供了</strong>手动消息确认</strong>和<strong>自动消息确认</strong>两种模式，通过<code>autoAck</code>关键词来选择模式。</p><p>RabbitMQ在默认情况下使用手动消息确认，应当通过<code>basicAck()</code>方法手动地进行确认。若消费者因为连接关闭、连接丢失等原因在消费途中死亡(未发送确认)，RabbitMQ会将消息重新排队，将其重新发送给另一个消费者，直到消息被确认或者超时(默认30min)为止。</p><p>在自动消息确认的情况下(即<code>autoAck=true</code>)，一个消息一旦被传递给C，就会立刻被标记为已删除，这种情况下无论是否被成功消费，该消息都会丢失。</p><h2 id="_5-交换机与路由" tabindex="-1"><a class="header-anchor" href="#_5-交换机与路由"><span>5.交换机与路由</span></a></h2><figure><img src="'+n+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p>上图是RabbitMQ消息队列的模型，X为交换机，生产者产生的消息会被传递给交换机(exchange)，交换机再根据需要将消息分配给相应的消息队列(需要与交换机进行绑定)，最后交付给对应的消费者。</p><p>为了实现几种角色之间的连接，明确<strong>路由</strong>关系，通过键来实现路由规则。</p><p>**路由键(Routing Key)**是消息的键，用于发送至交换机时指定路由规则</p><p>**绑定键(Binding Key)**是队列的键，用于将队列与交换机关联起来，不同队列可以拥有相同的键，一个队列也可以拥有多个不同的键，因此可以实现多绑定</p><p>交换机包括五种模式，如下：</p><ul><li><strong>直连(Direct)</strong>:将消息推送到<code>binding key</code>与消息<code>routing key</code>相同的队列，不匹配的消息会被丢失</li><li><strong>主题(Topic)</strong>:消息的<code>routing key</code>必须是由点号分隔的一系列单词(如alpha.beta.gamma)，队列的<code>binding key</code>也需要用点号分隔一系列单词和<code>#</code>、<code>*</code>，其中<code>#</code>表示匹配一个或多个任意单词，<code>*</code>表示匹配一个任意单词(类似正则表达式)。若键值为单个<code>#</code>，表示接收所有消息，若键值不包含<code>#</code>或<code>*</code>，工作模式与直连交换机完全相同。</li><li><strong>扇形(Fanout)</strong>:广播消息，会将消息传递给所有与该交换机绑定的队列，速度最快。该交换机不使用key</li><li><strong>首部(Headers)</strong>:类似HTTP，使用<code>Headers</code>头部将消息映射队列，用Object类型规则进行匹配。不使用key</li><li><strong>默认(Default)</strong>:实际上是名字为空字符串的直连交换机，所有新建队列都会自动绑定至默认交换机上，<code>routing key</code>与队列名称相同</li></ul><h2 id="_6-发布-订阅模式" tabindex="-1"><a class="header-anchor" href="#_6-发布-订阅模式"><span>6.发布-订阅模式</span></a></h2><p>一般的消息队列工作模式是一条消息经由一个消费者处理后完成生命周期(一对一)。而发布-订阅模式是向多个消费者发布同一条消息(一对多)。</p><p>实现发布订阅模式的方式是通过扇形交换机实现的</p>',26),s=[r];function c(l,p){return t(),a("div",null,s)}const g=e(i,[["render",c],["__file","RabbitMQ.html.vue"]]),h=JSON.parse('{"path":"/posts/study/RabbitMQ.html","title":"消息队列和RabbitMQ","lang":"zh-CN","frontmatter":{"date":"2024-09-09T00:00:00.000Z","category":["学习"],"tag":["面试"],"star":false,"sticky":false,"sidebar":false,"breadcrumb":false,"footer":"Be calm down.","description":"消息队列和RabbitMQ 1.简介 RabbitMQ是最常见的消息队列中间件之一，相比Kafka在中小型项目中应用更广。该文针对RabbitMQ在Java环境的使用进行展开。主要是通过RabbitMQ来深入理解消息队列(下简称MQ)这一种中间件。 该中间件是基于Erlang语言开发的，也自带Erlang的Emnesia分布式实时关系数据库 2.控制界...","head":[["meta",{"property":"og:url","content":"https://xavoric.github.io/Unisky-Blog/Unisky-Blog/posts/study/RabbitMQ.html"}],["meta",{"property":"og:site_name","content":"宙宇空"}],["meta",{"property":"og:title","content":"消息队列和RabbitMQ"}],["meta",{"property":"og:description","content":"消息队列和RabbitMQ 1.简介 RabbitMQ是最常见的消息队列中间件之一，相比Kafka在中小型项目中应用更广。该文针对RabbitMQ在Java环境的使用进行展开。主要是通过RabbitMQ来深入理解消息队列(下简称MQ)这一种中间件。 该中间件是基于Erlang语言开发的，也自带Erlang的Emnesia分布式实时关系数据库 2.控制界..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Unisky"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:published_time","content":"2024-09-09T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列和RabbitMQ\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-09T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Unisky\\"}]}"]]},"headers":[{"level":2,"title":"1.简介","slug":"_1-简介","link":"#_1-简介","children":[]},{"level":2,"title":"2.控制界面","slug":"_2-控制界面","link":"#_2-控制界面","children":[]},{"level":2,"title":"3.生产者(P)与消费者(C)","slug":"_3-生产者-p-与消费者-c","link":"#_3-生产者-p-与消费者-c","children":[]},{"level":2,"title":"4.消息确认机制","slug":"_4-消息确认机制","link":"#_4-消息确认机制","children":[]},{"level":2,"title":"5.交换机与路由","slug":"_5-交换机与路由","link":"#_5-交换机与路由","children":[]},{"level":2,"title":"6.发布-订阅模式","slug":"_6-发布-订阅模式","link":"#_6-发布-订阅模式","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.33,"words":1299},"filePathRelative":"posts/study/RabbitMQ.md","localizedDate":"2024年9月9日","excerpt":"\\n<h2>1.简介</h2>\\n<p>RabbitMQ是最常见的消息队列中间件之一，相比Kafka在中小型项目中应用更广。该文针对RabbitMQ在Java环境的使用进行展开。主要是通过RabbitMQ来深入理解消息队列(下简称MQ)这一种中间件。</p>\\n<p>该中间件是基于Erlang语言开发的，也自带Erlang的Emnesia分布式实时关系数据库</p>\\n<h2>2.控制界面</h2>\\n<p>通过<code>http://localhost:15672/</code>可以访问RabbitMQ的控制中心，需要输入账号密码，默认需要在localhost下使用guest/guest才能登陆。</p>","autoDesc":true}');export{g as comp,h as data};
