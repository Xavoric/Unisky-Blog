import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as l,e as n,a as s,b as a}from"./app-DrMrOvds.js";const p="/Unisky-Blog/assets/skiplist-DJzdtVMI.png",o="/Unisky-Blog/assets/read-4YG7ltNW.png",r={},c=n(`<h1 id="技术岗面试题小结-三" tabindex="-1"><a class="header-anchor" href="#技术岗面试题小结-三"><span>技术岗面试题小结（三）</span></a></h1><p>研发岗的面试问题可能不会局限于某个编程语言或者某个技术栈，有时候也会去问一些比较杂项的东西，所以这里单开一个系列来汇总这些杂项题目。可能会包括一些智力题和应用题</p><h2 id="_1-rpc" tabindex="-1"><a class="header-anchor" href="#_1-rpc"><span>1.RPC</span></a></h2><p><strong>远程过程调用(Remote Procedure Call)</strong> 是一种通过网络从远程计算机请求服务的协议。</p><p>是用于实现分布式计算的通信协议和编程模型，允许网络不同计算机之间互相通信和调用，其中提供服务的计算机被称为RPC服务器。</p><h2 id="_2-b-树与索引" tabindex="-1"><a class="header-anchor" href="#_2-b-树与索引"><span>2.b+树与索引</span></a></h2><p><strong>聚簇索引</strong>: 按照每张表的主键(PRIMARY KEY)构造一颗B+树，叶子节点存放整张表的记录数据。每张表只能有一个聚簇索引</p><ul><li>若表设置了主键，那主键就是聚簇索引</li><li>若表没有主键，选取第一个非NULL的UNIQUE列作为索引</li><li>都没有的情况默认创建隐藏row_id作为聚簇索引</li></ul><p><strong>非聚簇索引</strong>:又称普通索引或二级索引，即聚簇索引以外的索引。对InnoDB引擎(如MySQL),普通索引的叶子节点储存主键的值</p><ul><li><strong>回表查询</strong>：通过非聚簇索引定位主键，再根据主键的聚簇索引定位记录行。需要多查询一次索引树，性能较低。同时如果回表过程中发生了数据修改可能导致数据不一致</li><li><strong>索引覆盖</strong>：建立组合索引，将被查询的字段建立到联合索引中</li><li><strong>最左匹配原则</strong>：在联合索引中，若SQL语句用到了联合索引最左侧的索引，那么该语句可以利用这个联合索引去匹配</li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#现有索引(a,b,c)</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">#可以利用索引,用上a,b,c</span>
 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">#可以利用索引,用上a,b</span>
 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">#可以利用索引，用上a,b，mysql有查询优化器,会自动优化顺序）</span>
 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">#可以利用索引,用上a</span>
 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> b<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">#不可以利用索引</span>
 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> c<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">#可以利用索引，但只用上a索引，b,c索引用不到</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> a<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">and</span> b<span class="token operator">&gt;</span><span class="token number">1</span> <span class="token operator">and</span> c <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">#这样a,b可以用到索引，c用不到索引</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-跳表" tabindex="-1"><a class="header-anchor" href="#_3-跳表"><span>3.跳表</span></a></h2><p>跳表又叫跳跃列表(Skiplist)，本质是在有序链表的基础上增加&quot;跳跃&quot;的功能，即一个节点可能拥有多个向前的指针，分别跳跃不同的距离，如下图所示</p><figure><img src="`+p+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure>',14),i=s("p",null,[a("在遍历时从最上面的一行索引开始搜素，若大于待查找数则返回上一个节点，进入下一行索引开始遍历。整体的复杂度约为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"O"),s("mo",{stretchy:"false"},"("),s("mi",null,"l"),s("mi",null,"o"),s("mi",null,"g"),s("mi",null,"N"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"O(logN)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.01968em"}},"l"),s("span",{class:"mord mathnormal"},"o"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"g"),s("span",{class:"mord mathnormal",style:{"margin-right":"0.10903em"}},"N"),s("span",{class:"mclose"},")")])])]),a("，实质上是类似平衡树的数据结构")],-1),d=s("p",null,[a("每个节点在添加时会被"),s("strong",null,"随机"),a("指定一个层数，按照层数建立相应的索引，在不指定层数上限的情况下，产生"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"k"),s("mo",{stretchy:"false"},"("),s("mi",null,"k"),s("mo",null,">"),s("mn",null,"1"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"k(k>1)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03148em"}},"k"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},">"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mclose"},")")])])]),a("层节点的概率为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("msup",null,[s("mi",null,"p"),s("mi",null,"k")])]),s("annotation",{encoding:"application/x-tex"},"p^k")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1.0435em","vertical-align":"-0.1944em"}}),s("span",{class:"mord"},[s("span",{class:"mord mathnormal"},"p"),s("span",{class:"msupsub"},[s("span",{class:"vlist-t"},[s("span",{class:"vlist-r"},[s("span",{class:"vlist",style:{height:"0.8491em"}},[s("span",{style:{top:"-3.063em","margin-right":"0.05em"}},[s("span",{class:"pstrut",style:{height:"2.7em"}}),s("span",{class:"sizing reset-size6 size3 mtight"},[s("span",{class:"mord mathnormal mtight",style:{"margin-right":"0.03148em"}},"k")])])])])])])])])])]),a("，产生一层节点的概率为"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mn",null,"1"),s("mo",null,"−"),s("mi",null,"p")]),s("annotation",{encoding:"application/x-tex"},"1-p")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7278em","vertical-align":"-0.0833em"}}),s("span",{class:"mord"},"1"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"−"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal"},"p")])])])],-1),m=n(`<h2 id="_4-中间人攻击及预防" tabindex="-1"><a class="header-anchor" href="#_4-中间人攻击及预防"><span>4.中间人攻击及预防</span></a></h2><p><strong>中间人攻击(MITM, Man-in-the-Middle Attack)</strong> 是一种会话劫持攻击，中间人通过多种方式劫持并操纵篡改会话内容，使双方在不知情情况下被窃取信息或冒充访问。</p><p>执行中间人攻击的方式有DNS欺骗、ARP欺骗、仿冒Wi-Fi、恶意软件等方式，可以实现伪造网页、拦截流量数据等。</p><p>预防方法： 提高警惕性，不连接公开Wi-Fi、不打开钓鱼邮件、恶意软件等。部署防火墙、安全软件等</p><h2 id="_5-数据库中数据类型char和varchar的区别" tabindex="-1"><a class="header-anchor" href="#_5-数据库中数据类型char和varchar的区别"><span>5.数据库中数据类型char和varchar的区别</span></a></h2><p>char是固定长度字符串，varchar是可变长度字符串 其中char的存读速度更快</p><h2 id="_6-零拷贝" tabindex="-1"><a class="header-anchor" href="#_6-零拷贝"><span>6.零拷贝</span></a></h2><p>零拷贝(Zero Copy)指计算机执行操作时无需将数据在两个内存区域之间拷贝。可以减少数据在用户缓冲区与内核缓冲区之间的反复I/O，也可以减少用户进程地址空间和内核地址空间之间上下午切换带来的开销</p><h2 id="_7-linux如何修改系统时间" tabindex="-1"><a class="header-anchor" href="#_7-linux如何修改系统时间"><span>7.linux如何修改系统时间</span></a></h2><p>使用<code>date -s</code>命令进行修改</p><p>修改时区文件<code>/etc/timezone</code></p><h2 id="_8-redis分布式锁" tabindex="-1"><a class="header-anchor" href="#_8-redis分布式锁"><span>8.Redis分布式锁</span></a></h2><p>分布式锁是在分布式系统环境下，对共享资源进行访问控制的同步机制，防止多个节点操作同一数据。</p><p>分布式锁一般包括五个特性，但不一定包括，如下：</p><ul><li><strong>互斥性</strong>：同一时间只有一个节点获得锁</li><li><strong>不发生死锁</strong>：节点崩溃后锁可以被其他节点获取</li><li><strong>公平性</strong>：多个节点同时申请锁时，均有获得锁的机会</li><li><strong>可重入性</strong>：同一个节点可以多次获取同一个锁</li><li><strong>高可用</strong>：锁服务的故障不影响系统运行</li></ul><p>分布式锁的运行过程是： 请求锁→锁定资源→访问资源→释放锁</p><hr><p>Redis提供了实现分布式锁的相关命令： <code>SETNX</code>用于在key不存在时设置值，用于确保同一时间只有一个客户端能够获得锁 <code>EXPIRE</code>用于设置key过期时间，锁在一定时间后会释放，避免死锁 <code>DEL</code>用于删除key，主动释放锁</p><p>一般场合中使用<code>SET NX EX</code>命令，如下</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">//设置键值对，10s超时，若my_key存在不进行操作</span>
<span class="token constant">SET</span> my_key my_value <span class="token constant">NX</span> <span class="token constant">EX</span> <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>命令返回<code>OK</code>时说明获取锁，返回<code>nil</code>则表明锁已被其他节点持有</p><h2 id="_9-sql死锁" tabindex="-1"><a class="header-anchor" href="#_9-sql死锁"><span>9.SQL死锁</span></a></h2><p>sql死锁发生的主要原因是两个事物对表的锁定顺序不一致，导致闭环等待</p><p>模拟sql死锁:</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#事务1</span>
<span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> A <span class="token keyword">SET</span> num <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> A <span class="token keyword">SET</span> num <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
<span class="token comment">#事务2</span>
<span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> A <span class="token keyword">SET</span> num <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> A <span class="token keyword">SET</span> num <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">#事务1</span>
<span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> orders <span class="token keyword">SET</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;processing&#39;</span> <span class="token keyword">WHERE</span> order_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> products <span class="token keyword">SET</span> stock <span class="token operator">=</span> stock <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> product_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
<span class="token comment">#事务2</span>
<span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> products <span class="token keyword">SET</span> stock <span class="token operator">=</span> stock <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> product_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> orders <span class="token keyword">SET</span> <span class="token keyword">status</span> <span class="token operator">=</span> <span class="token string">&#39;processing&#39;</span> <span class="token keyword">WHERE</span> order_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>同时运行上述两个事务，两个事务执行完第一条后都会卡在第二条陷入死锁(已被另一个事务锁定)。</p><p>可见sql死锁一般存在下面两种情况：</p><ul><li>对于同一个表: 在事务中对同一个表进行多次操作，并在多线程的情况存在这样的事物，可能导致死锁</li><li>对于不同表: 多个事务对表的操作顺序不同，发生交叉，导致死锁</li></ul><p>sql死锁的解决方案：</p><ul><li>大事务拆成小事务</li><li>若存在相同业务则不再更新数据</li><li>调整数据表的修改顺序</li><li>降低并发，避免多线程</li><li>设置重试机制</li></ul><h2 id="_10-数据库三范式" tabindex="-1"><a class="header-anchor" href="#_10-数据库三范式"><span>10.数据库三范式</span></a></h2><ul><li><p><strong>第一范式(1NF):原子性</strong> 数据应当不可进一步再分</p></li><li><p><strong>第二范式(2NF):唯一性</strong> 非主键字段的值应当完全依赖于唯一主键(即通过主键的值可以唯一确定值)，通过分表等方式隔离联合主键</p></li><li><p><strong>第三范式(3NF)</strong> 非主键字段完全依赖于主键字段的同时，不能依赖于其他非主键字段(即通过确认非主键的值可以确认值)。通过分表等方式隔离表信息，一个表只存一种数据</p></li></ul><p>三范式不是硬性要求，实际设计要根据需求来</p><h2 id="_11-sql事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#_11-sql事务的隔离级别"><span>11.SQL事务的隔离级别</span></a></h2><p>SQL事务有<strong>四种</strong>隔离级别，按保护程度从低到高如下所示：</p><figure><img src="`+o+'" alt="alt text" tabindex="0" loading="lazy"><figcaption>alt text</figcaption></figure><p><strong>(1).读未提交(Read uncommitted)</strong>: 一个事务可以读取另一个事务中没提交的更新数据。保护程度最小，会发生脏读，但性能更好。</p><p><strong>(2).读已提交(Read committed)</strong>: 一个事务只能读取已提交的数据，但是可能读取到被多次提交后发生变化的数据，导致前后数据值不同</p><p><strong>(3).可重复读(Repeatable read)</strong>: 在读已提交的基础上保证了数据在事务起始结束之间的一致性，可能发生幻读</p><p><strong>(4).串行化(Serializable)</strong>: 最严格的事务隔离，所有事务串行执行，性能最低。</p>',41),k=[c,i,d,m];function u(h,g){return t(),l("div",null,k)}const y=e(r,[["render",u],["__file","Interview3.html.vue"]]),w=JSON.parse('{"path":"/posts/study/Interview3.html","title":"技术岗面试题小结（三）","lang":"zh-CN","frontmatter":{"date":"2024-09-09T00:00:00.000Z","category":["学习"],"tag":["面试"],"star":false,"sticky":false,"sidebar":false,"breadcrumb":false,"footer":"Nothing can tear us apart.","description":"技术岗面试题小结（三） 研发岗的面试问题可能不会局限于某个编程语言或者某个技术栈，有时候也会去问一些比较杂项的东西，所以这里单开一个系列来汇总这些杂项题目。可能会包括一些智力题和应用题 1.RPC 远程过程调用(Remote Procedure Call) 是一种通过网络从远程计算机请求服务的协议。 是用于实现分布式计算的通信协议和编程模型，允许网络不...","head":[["meta",{"property":"og:url","content":"https://xavoric.github.io/Unisky-Blog/Unisky-Blog/posts/study/Interview3.html"}],["meta",{"property":"og:site_name","content":"宙宇空"}],["meta",{"property":"og:title","content":"技术岗面试题小结（三）"}],["meta",{"property":"og:description","content":"技术岗面试题小结（三） 研发岗的面试问题可能不会局限于某个编程语言或者某个技术栈，有时候也会去问一些比较杂项的东西，所以这里单开一个系列来汇总这些杂项题目。可能会包括一些智力题和应用题 1.RPC 远程过程调用(Remote Procedure Call) 是一种通过网络从远程计算机请求服务的协议。 是用于实现分布式计算的通信协议和编程模型，允许网络不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Unisky"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:published_time","content":"2024-09-09T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"技术岗面试题小结（三）\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-09-09T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Unisky\\"}]}"]]},"headers":[{"level":2,"title":"1.RPC","slug":"_1-rpc","link":"#_1-rpc","children":[]},{"level":2,"title":"2.b+树与索引","slug":"_2-b-树与索引","link":"#_2-b-树与索引","children":[]},{"level":2,"title":"3.跳表","slug":"_3-跳表","link":"#_3-跳表","children":[]},{"level":2,"title":"4.中间人攻击及预防","slug":"_4-中间人攻击及预防","link":"#_4-中间人攻击及预防","children":[]},{"level":2,"title":"5.数据库中数据类型char和varchar的区别","slug":"_5-数据库中数据类型char和varchar的区别","link":"#_5-数据库中数据类型char和varchar的区别","children":[]},{"level":2,"title":"6.零拷贝","slug":"_6-零拷贝","link":"#_6-零拷贝","children":[]},{"level":2,"title":"7.linux如何修改系统时间","slug":"_7-linux如何修改系统时间","link":"#_7-linux如何修改系统时间","children":[]},{"level":2,"title":"8.Redis分布式锁","slug":"_8-redis分布式锁","link":"#_8-redis分布式锁","children":[]},{"level":2,"title":"9.SQL死锁","slug":"_9-sql死锁","link":"#_9-sql死锁","children":[]},{"level":2,"title":"10.数据库三范式","slug":"_10-数据库三范式","link":"#_10-数据库三范式","children":[]},{"level":2,"title":"11.SQL事务的隔离级别","slug":"_11-sql事务的隔离级别","link":"#_11-sql事务的隔离级别","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.25,"words":2175},"filePathRelative":"posts/study/Interview3.md","localizedDate":"2024年9月9日","excerpt":"\\n<p>研发岗的面试问题可能不会局限于某个编程语言或者某个技术栈，有时候也会去问一些比较杂项的东西，所以这里单开一个系列来汇总这些杂项题目。可能会包括一些智力题和应用题</p>\\n<h2>1.RPC</h2>\\n<p><strong>远程过程调用(Remote Procedure Call)</strong> 是一种通过网络从远程计算机请求服务的协议。</p>\\n<p>是用于实现分布式计算的通信协议和编程模型，允许网络不同计算机之间互相通信和调用，其中提供服务的计算机被称为RPC服务器。</p>\\n<h2>2.b+树与索引</h2>\\n<p><strong>聚簇索引</strong>: 按照每张表的主键(PRIMARY KEY)构造一颗B+树，叶子节点存放整张表的记录数据。每张表只能有一个聚簇索引</p>","autoDesc":true}');export{y as comp,w as data};
