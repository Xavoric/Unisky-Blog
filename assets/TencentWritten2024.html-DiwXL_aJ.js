import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as n,o as m,c as r,a as s,b as a,d as t,e as i}from"./app-DrMrOvds.js";const c={},p=i('<h1 id="腾讯实习生笔试经历" tabindex="-1"><a class="header-anchor" href="#腾讯实习生笔试经历"><span>腾讯实习生笔试经历</span></a></h1><h2 id="_0-笔试过程" tabindex="-1"><a class="header-anchor" href="#_0-笔试过程"><span>0.笔试过程</span></a></h2><p>笔试是在牛客网进行线上笔试，两个小时完成五道编程题，难度不一，与顺序无关。</p><p>笔试下来感觉一道题大约半个小时左右，一共只做出来三道题，还有半小时一直在对剩下两道题干瞪眼</p><h2 id="_1-第一题" tabindex="-1"><a class="header-anchor" href="#_1-第一题"><span>1.第一题</span></a></h2><p>第一题是对无向图的各边染红或者黑色，要求返回图中连接的边全为红边的节点个数</p><p>用二维数组会直接爆内存（稀疏矩阵），所以要用链表，不需要储存相连结点，只需要储存相连边的颜色就行</p><h2 id="_2-第二题" tabindex="-1"><a class="header-anchor" href="#_2-第二题"><span>2.第二题</span></a></h2><p>第二题是给定一个链表数组，问其每一个链表分成两部分再重新连接后能否实现升序排列。</p><p>应该是最简单的问题，只要了解过链表数据结构就可以直接秒，由于只需要考虑分两段，所以直接寻找中间发生降序变化的地方就行。</p><ul><li>如果发生两次以上降序变化，必定不能仅通过一次重组就达到有序</li><li>如果没有发生降序变化，说明本就有序</li><li>如果仅发生一次降序变化，需要比较两边的首尾数字大小，判断是否能够重组有序</li></ul><h2 id="_3-第三题" tabindex="-1"><a class="header-anchor" href="#_3-第三题"><span>3.第三题</span></a></h2><p>第三题是给定一个非连通图，问有多少个方案在仅添加一条边的情况下将其转化成连通图。</p><p>。。。懵逼了，可以判断连通图，但是还真不知道怎么找出所有的加边方案，感觉暴力也很难解。需要学习的东西+1</p><p>因为看到图，一直在往图论那边去想，但是现在看了题解发现比想象的简单很多。</p><p>这一题是用<strong>并查集</strong>的思想，将所有内部连通的点归属为一个集合，这样最后可以得到n个连通块，如果n&gt;2，说明无法通过一条边令其成为连通图。n=1时，两边的节点个数分别为a和b，可以通过a*b来计算方案个数</p><p>被无向图的描述误导了，思维还是太局限了。</p><h3 id="第三题扩展" tabindex="-1"><a class="header-anchor" href="#第三题扩展"><span>第三题扩展</span></a></h3>',18),o={href:"https://ac.nowcoder.com/acm/problem/14685",target:"_blank",rel:"noopener noreferrer"},h=s("h2",{id:"_4-第四题",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_4-第四题"},[s("span",null,"4.第四题")])],-1),g=s("p",null,"给定一个长度为n的数组，将其分为k段，每一段内的数逐个进行位异或计算，再将每一段得到的数求和。问能够得到的最大的数是多少。",-1),d=s("p",null,"龟龟，傻眼了，前两天刚好探讨了一下加法和异或运算的联系，这里考到了，但是完全不会做。应该是最难题。",-1),u=s("p",null,"毫无疑问是臭名昭著的dp问题，在解决这个问题之前，我们要先明确一下异或计算的特性",-1),y=s("ul",null,[s("li",null,[a("可交换："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x"),s("mo",null,"⊕"),s("mi",null,"y"),s("mo",null,"="),s("mi",null,"y"),s("mo",null,"⊕"),s("mi",null,"x")]),s("annotation",{encoding:"application/x-tex"},"x \\oplus y = y \\oplus x")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal"},"x")])])]),a(", 即x^y=y^x")]),s("li",null,[a("可结合："),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x"),s("mo",null,"⊕"),s("mi",null,"y"),s("mo",null,"⊕"),s("mi",null,"z"),s("mo",null,"="),s("mo",{stretchy:"false"},"("),s("mi",null,"x"),s("mo",null,"⊕"),s("mi",null,"y"),s("mo",{stretchy:"false"},")"),s("mo",null,"⊕"),s("mi",null,"z"),s("mo",null,"="),s("mi",null,"x"),s("mo",null,"⊕"),s("mo",{stretchy:"false"},"("),s("mi",null,"y"),s("mo",null,"⊕"),s("mi",null,"z"),s("mo",{stretchy:"false"},")")]),s("annotation",{encoding:"application/x-tex"},"x \\oplus y \\oplus z = (x \\oplus y) \\oplus z = x \\oplus ( y \\oplus z)")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.7778em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mclose"},")"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mopen"},"("),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mclose"},")")])])]),a(",即x^y^z可以任意结合")]),s("li",null,[a("逆运算: 对于"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x"),s("mo",null,"⊕"),s("mi",null,"y"),s("mo",null,"="),s("mi",null,"z")]),s("annotation",{encoding:"application/x-tex"},"x \\oplus y = z")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z")])])]),a("，任意交换其中两个数，仍成立，如"),s("span",{class:"katex"},[s("span",{class:"katex-mathml"},[s("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[s("semantics",null,[s("mrow",null,[s("mi",null,"x"),s("mo",null,"⊕"),s("mi",null,"z"),s("mo",null,"="),s("mi",null,"y")]),s("annotation",{encoding:"application/x-tex"},"x \\oplus z = y")])])]),s("span",{class:"katex-html","aria-hidden":"true"},[s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.6667em","vertical-align":"-0.0833em"}}),s("span",{class:"mord mathnormal"},"x"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}}),s("span",{class:"mbin"},"⊕"),s("span",{class:"mspace",style:{"margin-right":"0.2222em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.4306em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.04398em"}},"z"),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}}),s("span",{class:"mrel"},"="),s("span",{class:"mspace",style:{"margin-right":"0.2778em"}})]),s("span",{class:"base"},[s("span",{class:"strut",style:{height:"0.625em","vertical-align":"-0.1944em"}}),s("span",{class:"mord mathnormal",style:{"margin-right":"0.03588em"}},"y")])])]),a("，因此可以通过结果z反求x或y")])],-1),_={href:"https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/description/",target:"_blank",rel:"noopener noreferrer"},x=s("p",null,"回到原题上面，总体解题思路是动态规划",-1),b=s("p",null,"用一个二维dp数组对结果进行维护，对于dp[n][k],表示前n个数分成k段得到的最大结果",-1),f=s("p",null,"后面鸽了，找不到原题不好落实想法",-1),k=s("h2",{id:"_5-第五题",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_5-第五题"},[s("span",null,"5.第五题")])],-1),v=s("p",null,"给定一个字符矩阵，从任意一个位置出发，可以向上下左右任意一个方向移动（不能超出矩阵），要求找出能够形成tencent序列单词的数量。",-1),w=s("p",null,"用二维char储存，然后确定起点（或者终点），直接暴力递归解pass了，不知道有没有更好的方案。",-1);function z(T,M){const e=n("ExternalLinkIcon");return m(),r("div",null,[p,s("p",null,[a("和上面的题非常类似，思路是一样的。 给你一个 n 个点，m 条边的无向图，求至少要在这个的基础上加多少条无向边使得任意两个点可达 "),s("a",o,[a("扩展题"),t(e)])]),h,g,d,u,y,s("p",null,[s("a",_,[a("（LC2433）用这道题更好理解一下异或计算的特性"),t(e)])]),x,b,f,k,v,w])}const Z=l(c,[["render",z],["__file","TencentWritten2024.html.vue"]]),B=JSON.parse('{"path":"/posts/study/TencentWritten2024.html","title":"腾讯实习生笔试经历","lang":"zh-CN","frontmatter":{"date":"2024-03-31T00:00:00.000Z","category":["学习"],"tag":["笔试","算法","数据结构"],"star":false,"sticky":false,"sidebar":false,"breadcrumb":false,"footer":"I will reach the star.","description":"腾讯实习生笔试经历 0.笔试过程 笔试是在牛客网进行线上笔试，两个小时完成五道编程题，难度不一，与顺序无关。 笔试下来感觉一道题大约半个小时左右，一共只做出来三道题，还有半小时一直在对剩下两道题干瞪眼 1.第一题 第一题是对无向图的各边染红或者黑色，要求返回图中连接的边全为红边的节点个数 用二维数组会直接爆内存（稀疏矩阵），所以要用链表，不需要储存相连...","head":[["meta",{"property":"og:url","content":"https://xavoric.github.io/Unisky-Blog/Unisky-Blog/posts/study/TencentWritten2024.html"}],["meta",{"property":"og:site_name","content":"宙宇空"}],["meta",{"property":"og:title","content":"腾讯实习生笔试经历"}],["meta",{"property":"og:description","content":"腾讯实习生笔试经历 0.笔试过程 笔试是在牛客网进行线上笔试，两个小时完成五道编程题，难度不一，与顺序无关。 笔试下来感觉一道题大约半个小时左右，一共只做出来三道题，还有半小时一直在对剩下两道题干瞪眼 1.第一题 第一题是对无向图的各边染红或者黑色，要求返回图中连接的边全为红边的节点个数 用二维数组会直接爆内存（稀疏矩阵），所以要用链表，不需要储存相连..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-06T08:08:36.000Z"}],["meta",{"property":"article:author","content":"Unisky"}],["meta",{"property":"article:tag","content":"笔试"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:tag","content":"数据结构"}],["meta",{"property":"article:published_time","content":"2024-03-31T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-06T08:08:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"腾讯实习生笔试经历\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-31T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-06T08:08:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Unisky\\"}]}"]]},"headers":[{"level":2,"title":"0.笔试过程","slug":"_0-笔试过程","link":"#_0-笔试过程","children":[]},{"level":2,"title":"1.第一题","slug":"_1-第一题","link":"#_1-第一题","children":[]},{"level":2,"title":"2.第二题","slug":"_2-第二题","link":"#_2-第二题","children":[]},{"level":2,"title":"3.第三题","slug":"_3-第三题","link":"#_3-第三题","children":[{"level":3,"title":"第三题扩展","slug":"第三题扩展","link":"#第三题扩展","children":[]}]},{"level":2,"title":"4.第四题","slug":"_4-第四题","link":"#_4-第四题","children":[]},{"level":2,"title":"5.第五题","slug":"_5-第五题","link":"#_5-第五题","children":[]}],"git":{"createdTime":1725610116000,"updatedTime":1725610116000,"contributors":[{"name":"Xavoric","email":"3024008334@qq.com","commits":1}]},"readingTime":{"minutes":3.61,"words":1083},"filePathRelative":"posts/study/TencentWritten2024.md","localizedDate":"2024年3月31日","excerpt":"\\n<h2>0.笔试过程</h2>\\n<p>笔试是在牛客网进行线上笔试，两个小时完成五道编程题，难度不一，与顺序无关。</p>\\n<p>笔试下来感觉一道题大约半个小时左右，一共只做出来三道题，还有半小时一直在对剩下两道题干瞪眼</p>\\n<h2>1.第一题</h2>\\n<p>第一题是对无向图的各边染红或者黑色，要求返回图中连接的边全为红边的节点个数</p>\\n<p>用二维数组会直接爆内存（稀疏矩阵），所以要用链表，不需要储存相连结点，只需要储存相连边的颜色就行</p>\\n<h2>2.第二题</h2>\\n<p>第二题是给定一个链表数组，问其每一个链表分成两部分再重新连接后能否实现升序排列。</p>\\n<p>应该是最简单的问题，只要了解过链表数据结构就可以直接秒，由于只需要考虑分两段，所以直接寻找中间发生降序变化的地方就行。</p>","autoDesc":true}');export{Z as comp,B as data};
